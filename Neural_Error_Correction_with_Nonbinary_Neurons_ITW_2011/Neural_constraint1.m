%%=========================================================================
%********************************READ ME***********************************
%==========================================================================

%--------------------------------Summary-----------------------------------
% This file contains the code for simulating the error correcting procedure
% in a bipartite non-binary neural associative memory that enforces a set
% of constraints on the memorized patterns. As input, the code gets the 
% number of neurons on each side, the avergae node degree for each set of
% nodes, the number of initial erroneous bits, the maxium amplitude of
% noise, the maximum and minimum values for the firing rate of pattern
% neurons. The code then generates a number of random graphs, also
% specified by the input parameters, and simulate a number of instances by
% initializing the network with the all-zero pattern plus noise. The
% desired behavior is that the network converges to the all-zero pattern
% after a number of steps. Note that noise here is modeled by an integer
% in the interval [-max_noise_amp,max_noise_amp] excluding zero. 

% IMPORTANT NOTE: As explained above, this code is only concerned with the
% error correction capability and does not worry about what the actual
% patterns are. That's why the all-zero pattern is considered as the
% initial pattern. For the same reason, the firing threshold for the
% constraint nodes were also set to zero. Hence, this piece of code tries
% to solve Hx=0, where x is the noise and H is the randomly-generated
% constraint matrix. 
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
%----------------------HOW THE CODE WORKS IN DETAILS-----------------------
%--------------------------------------------------------------------------
% Given the input parameters, the code generates a number of random 
% constraint matrices H. For each matrix, a random intger-valued noise is
% produced in which each element is an integer in the interval 
% [-max_noise_amp,max_noise_amp] excluding zero. 

% At this point, the code iterates and update the state of neurons
% according to the rules mentioned in the paper: "Exponential Pattern 
% Retrieval Capacity with Non-Binary Associative Memory" by R. K. Kumar,
% A. H. Salavati and A. Shokrollahi. 
% If the convergence flag is set to 1, then the code iterates until
% convergence is reached or max_itr iterations is done. If the flag is set
% to zero, then the code does max_itr iterations, no matter if the
% convergence is reached or not. After finishing the iterations, the code
% checks if the final state of neurons is the all-zero vector. If not, an
% error is declared and error_count is increased. The overall error_count
% divided by the total number of iterations then represent the performance
% of the error correcting algorithm

% The results will be stored in a file on the specified location in the end
% of the code. The progress is also displayed on the screen.

% IMPORTANT NOTE: The arithmetic operations in this code are implemented
% based on the fact that the constraint matrix H is sparse. Therefore,
% instead of generating and stoing H completely, we only store the
% positions with non-zero values. Hence, two versions of H is generated
% each time: H_row, in which each row stores the positions of the non-zero
% elements in the corresponding row of H, and H_column, in which each
% column stores stores the positions of the non-zero elements in the 
% corresponding column of H. 
%==========================================================================
%==========================================================================


function Neural_constraint1 (N,K,error_bits)
%=============================INITIALIZATION===============================

if (~exist('initialization_done','var'))    % If already not initialized by the GUI...
    %-------------------------Simulation Parameters------------------------
    convergence_flag = 1;                   % 0 means you repeat for max_itr times. 1 means you wait untill convergence or do max_itr iteration
    max_itr = 10;                           % This is the maximum number of iteration for the simulation in convergence_flag = 0
    max_simulated_instances=10000;         % This is the maximum number of memorized sequences picked randomly and fed to the network in the recall phase
    algorithm_option = 1;                   % If it is equal to zero, we use winner-take-all algorithm. If 1, bit flipping is used. 
    no_ensemble_generated = 5;              % This is the number different random ensembles generated by the program. For Gold sequences it can be set to 1.
    %----------------------------------------------------------------------

    %-------------------------Network Parameters---------------------------
%     N = 400;                                % N is the number of neurons in network.
%     K = 100;                                 % K is the number of message bits.
    N_const = N-K;                          % N_cost represents the number of constraints.
    deg_column_H = 4;                       % This is the average degree of each column.
    deg_row_H = 8;
    %----------------------------------------------------------------------

    %--------------------------Neural Parameters---------------------------
    y_max = 200;                            % This is the maximum value of code nodes.
    y_min = -200;                           % This is the minimum value of code nodes.   
    gamma = 0.85;                            % gamma is the update threshold for the bit-flipping algorithm.
    %----------------------------------------------------------------------


    %--------------------------Noise Parameters----------------------------
%     error_bits = [1];                     % This is the number of erroneous bits
    max_noise_amp = 1;                        % This is the maximum absolute value that each error bit can have
    %----------------------------------------------------------------------
end

%----------------------------Other Initializations-------------------------
theta = zeros(N_const,1);               % theta is the firing threshold for each constraint node.
W = zeros(N,K);                         % W is the weight matrix
error_count = zeros(1,length(error_bits));            % This tracks the number of errors.

a=clock;                                % Initialize the seed for random number generation with the clock value.
RandStream.setDefaultStream(RandStream('mt19937ar','seed',sum(100*a))); 

N_orig = N;                             % N_orig keeps the original value of N.
K_orig = K;                             % To save the original value as K is updated during the algorithm.
termination_flag = 0;                   % The flag will be triggered whenever the stop button is pressed. 
tic                                     % Reset the timer for display purposes.
%--------------------------------------------------------------------------

%==========================================================================

111
%%
%================================MAIN LOOP=================================
for noise_itr = 1:length(error_bits)    
    err_bits = error_bits(noise_itr);   % Determine the number of erroneous bits.
    if (termination_flag == 1)          % If GUI stop button has been pressed, stop the script.    
        break;
    end
   
    for ensemble_loop = 1:no_ensemble_generated              
        inconsistent_flag = 0;          % When set to 1, this flag means the set of equations Hx = 0 is infeasible.        
        
        if (termination_flag == 1)      % If GUI stop button has been pressed, stop the script.
            break;
        end

        %-------------------BUILD THE CONSTRAINTS SYSTEM-------------------               
        [H_column,H_row] = random_matrix_sparse(N_orig-K_orig,N_orig,deg_column_H,deg_row_H);   % Generate a random constraint matrix. 
        [tt,N] = size(H_column);        % Update N as the number of columns in H_column might be smaller than N_orig since random_matrix_sparse removes duplicate columns in the produced constraint matrix. 
        [N_const,tt] = size(H_row);     % Update N_const.
        K = N-N_const;                  % Update K according to the new N (after removing duplicate columns in H).        
        
        if (N<=N_const)                 % If the number of constraints are larger than the size of the patterns, then declare an error by triggering the inconsistent_flag.
            inconsistent_flag = 1;
        end        
        %------------------------------------------------------------------
        
        
        if (inconsistent_flag == 0)     % If the system of equations is feasible then proceed.               

            
            for net_simul_itr = 1:max_simulated_instances   % Simulate the error correction procedure for the given ensemble.
                
                if (termination_flag == 1)      % If GUI stop button has been pressed, stop the script.
                    break;
                end
                                
                
                %-----------------------Generate Noise---------------------
                nois = zeros(1,N);
                pp = 1+floor((N-1)*rand(1,err_bits));        
                for h = 1:err_bits
                    nois(pp(h)) =(1+floor((max_noise_amp)*rand))*((-1)^randint);
                end        
                %----------------------------------------------------------
    
        
                %--------Initialize the Network with a Noisy Pattern-------              
                x = zeros(1,N);                                         % Initialize the network with a nosiy version of the pattern
                syndrome = sparse_mul_column(H_column,nois',N_const);   % Syndrome is the result of linear summation of noise input at the constraint nodes. 
                %----------------------------------------------------------
            
        
        
                %------------------Iterate Until Convergence---------------
                exit_flag = 0;
                itr = 0;
                while (exit_flag == 0)
                    
%                     %----Pause/Stop if the GUI buttons has been pressed----
%                     if (exist('initialization_done','var'))                       
%                         if (get(handles.OK_button,'UserData') ==0)          % If the GUI's "pause" button has been pressed...
%                             h = msgbox('The code is paused now. You can monitor variables and the progress. Once finished, please type "return" and press enter.','Warning','warn');
%                             uiwait(h) 
%                             set(handles.Pause_button,'String','Resume');
%                             keyboard;                        
%                             set(handles.OK_button,'UserData',1);
%                             guidata(hObject, handles);
%                             set(handles.Pause_button,'String','Pause');
% 
%                         elseif (get(handles.OK_button,'UserData') ==2)      % If the GUI's "stop" button has been pressed...
%                             exit_flag = 1;
%                             termination_flag = 1;
%                         end
%                     end
%                     %------------------------------------------------------
                    
                    itr = itr + 1;
                    
                    %----------------Update Constraint Nodes---------------
                    c_temp = syndrome-(sparse_mul_column(H_column,x',N_const) - theta);     % Find which constraint nodes are violated.
                
                    for iii = 1:N_const
                        if (abs(c_temp(iii))<.001)      % Take care of numerical issues
                            c_temp(iii) = 0;
                        end
                    end
            
                    c = sign(c_temp);       % c is the vector of constraint nodes and non-zero positions indicate a constraint violation.                    
                    %------------------------------------------------------

                    %------------------Update Pattern Nodes----------------
                    x_temp = sparse_mul_row(H_row,c',N);    %x_temp is the raw feedback received by each pattern node.
                    temp_var = zeros(1,N);
                    
                    for jjj = 1:length(temp_var)
                        temp_var(jjj) = abs(x_temp(jjj))/sum(extract_column(H_column,jjj,N_const));     % Divide the number of feedbacks received by the out-going degree                            
                    end
                    [x_max,inde] = max(temp_var);           % Find the node(s) with the maximum input sum.
                        
                    
                    if (algorithm_option == 0)
                        %----------------Winner-Take-All-------------------
                        x(inde)=x(inde)+sign(x_temp(inde)); % Update the code nodes.
                        %--------------------------------------------------
                    else                        
                        %-------------------Bit Flipping-------------------
                        x_temp2 = sparse_mul_row(H_row,abs(c'),N);
                        tempp = zeros(1,N);
                        for jjj = 1:N
                            if ( x_temp2(jjj)> gamma*sum(extract_column(H_column,jjj,N_const)))           % Update all the nodes that receive a lot of feedback from their neighbors.                    
                                tempp(jjj) = sign(x_temp(jjj));                            
                            end
                        end
                        x = x + tempp;
                        %--------------------------------------------------
                    end

                    x = max(x,y_min*ones(1,N));         % Wacth for saturations
                    x = min(x,y_max*ones(1,N));         % Wacth for saturations
                    %------------------------------------------------------
                    
            
                    %------------------Check for Convergence---------------
                    if (convergence_flag == 0)      % If 0, do max_itr iterations and quite
                        if (itr >=max_itr)
                            exit_flag = 1;                    
                        end
                    else                            % Else, remain in the loop until convergence or exceeding 1000 iterations.
                        if ((norm(c) < 0.0001)||(itr > 2*max_noise_amp*err_bits))
                            exit_flag = 1;        
                        end
                    end
                    %------------------------------------------------------
                end
                        
                %----------------------------------------------------------
        
        
            
                %-------Calculate Error Rate and Display Progress----------
                if ((norm(syndrome - sparse_mul_column(H_column,x',N_const))>.0001))           
                    error_count(noise_itr) = error_count(noise_itr) + 1;                                        
                end
                %----------------------------------------------------------
                
                %----------Display Results Every 1000 Iterations-----------                
%                 if (mod(net_simul_itr+(ensemble_loop-1)*max_simulated_instances,100) == 0)
%                 if (toc >= 1000)
%                    
%                    if (~exist('initialization_done','var'))                       
%                        display(['Iteration:',num2str(net_simul_itr+(ensemble_loop-1)*max_simulated_instances), ' Error count so far: ',num2str(error_count(noise_itr))]); 
%                    else
%                        set(handles.current_ensemble,'String',num2str(ensemble_loop));
%                        set(handles.initial_errors,'String',num2str(err_bits));
%                        set(handles.cur_simul_itr,'String',num2str(net_simul_itr+(ensemble_loop-1)*max_simulated_instances));
%                        set(handles.curr_error_rate,'String',num2str(error_count(noise_itr)/(net_simul_itr*ensemble_loop)));
%                        
%                        pause(0.001);
%                    end
%                    tic
%                 end                                
                %----------------------------------------------------------
            end
        end

    end
                 
     display(' ');
     display(['Noise itr = ',num2str(noise_itr),'out of ',num2str(length(error_bits))]);
     display(['Error rate = ',num2str(error_count(noise_itr)/(net_simul_itr*ensemble_loop))]);    

    error_rate = error_count/(net_simul_itr*ensemble_loop);
%==========================================================================




%%
    %=================================SAVE RESULTS=============================
    fid = fopen('neural_contraint_results.txt', 'a+');
    fprintf(fid, 'err_bits \t %d \t error_rate \t %f \n',err_bits, error_count(noise_itr)/(net_simul_itr*ensemble_loop));
    fclose(fid);
    %==========================================================================
end


%%
%================================Reset GUI Data============================
% if (exist('initialization_done','var'))    % If GUI is being used...
%     set(handles.OK_button,'UserData',2);        %Reset the UserData value
%     
%     %------------------------Reset the Displays----------------------------
%     set(handles.Pause_button,'Visible','off');
%     set(handles.OK_button,'String','Start');    
%     set(handles.current_ensemble,'String','');                                          
%     set(handles.initial_errors,'String','');                    
%     set(handles.cur_simul_itr,'String','');                    
%     set(handles.curr_error_rate,'String','');    
%     %----------------------------------------------------------------------
% end
%==========================================================================