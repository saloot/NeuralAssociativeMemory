%==========================================================================
%******************FUNCTION: read_journal_results**************************
%==========================================================================

%--------------------------------INPUTS------------------------------------
% N_in: The number of pattern nodes in the graph
% K_in: The dimension of the subspace of the pattern nodes
% L_in: The number of clusters if we have multiple levels (L = 1 for single level)
% alpha0: The step size in the learning algorithm
% beta0: The sparsity penalty coefficient in the learning algorithm
% theta0: The sparsity threshold in the learning algorithm
% gamma_BFO: The update threshold in the original bit-flipping recall algorithm 
% gamma_BFS: The update threshold in the simplified (yet better) bit-flipping recall algorithm 
%--------------------------------------------------------------------------

%--------------------------------OUTPUTS-----------------------------------
% processed_error_bits: The list of processed number of initial erroneous nodes
% processed_PER_WTA: The list of processed Pattern Error Rates for the Winner-Take-All algorithm
% processed_PER_BFO: The list of processed Pattern Error Rates for the original bit-flipping algorithm
% processed_PER_BFS: The list of processed Pattern Error Rates for the simplified bit-flipping algorithm
%--------------------------------------------------------------------------


%--------------------------FUNCTION DESCRIPTION----------------------------
% This function gets the specification of a clustered neural associative
% memory and reads the result of recall phase from the appropriate files. 
% The results will then be plotted and compared with theoretical values. 
%--------------------------------------------------------------------------

%==========================================================================
%==========================================================================



%=============================INITIALIZATION===============================

%----------------Load the Saved Initialized Parameters---------------------
%load(['./Initialization_Files/N_',num2str(N),'_K_',num2str(K),'/neural_journal_parameters_v1_N_',num2str(N),'_K_',num2str(K),'.mat']);           
%--------------------------------------------------------------------------

%-------------------------Simulation Variables-----------------------------
if (~exist('initialization_done_by_master','var') && ~exist('initialization_done_by_main','var'))    % If already not initialized by the GUI..
    K = 150;                            % Number of message bits
    N = 300;                            % Number of pattern neurons in the network
    Q = 8;                              % Number of quantization levels
    const_to_learn = 150;               % Number of contraints to learn over the patterns
    random_dataset_flag = 1;            % If 1, this flag tells the code to use the dataset generated by the file "neural_initialization.m". If 0, it will read the dataset from the file specified by the user
    index_in = 1;                       % Index of the random graph in the considered ensemble (for random_dataset_flag =1)    
    no_simulated_instances = 1000;      % The number of patterns that are going to be denoised during the recall phase
    max_noise_amp = 1;                  % Maximum value of integer-valued noise added to each bit
    err_bits_range = [0:10];            % The number of bits that will be corrupted initially for the recall phase
    gamma_BFO = 0.95;                   % The update threshold for the Original Bit flipping algorithm
    gamma_BFS = 0.95;                   % The update threshold for the Simplified Bit flipping algorithm
    theta0 = 0.02;                      % The initial sparisty threshold
    alpha0 = 0.9;                       % The initial learning rate
    beta0 = 0.8;                        % The sparsity penalty
    nu = 0.025;                         % update threshold for the constraint neurons during the recall phase
    index_max = 1;                      % This is the maximum number of random scenarios generated for simulation    
end
%--------------------------------------------------------------------------

warning off
%%
%--------------------------Other Variables---------------------------------
if (~exist('plot_flag','var'))
    plot_flag = 1;                              % If 1, tells the code to plot the results
end
hist_x_axis_itr = [0:20:1000];              % This is bin places for total learning iterations histogram
hist_x_axis_sparsity = [0:.05:1];           % This is bin places for total sparsity percentage

hist_x_itr = [];                            % This is output bin places produced BY the hist command for total learning iterations (to be used in bar plots)
hist_x_sparsity = [];                       % This is output bin places produced BY the hist command for sparsity percentage (to be used in bar plots)

hist_out_itr = [];                          % This is output values produced by the hist command for total learning iterations (to be used in bar plots)
hist_out_sparsity = [];                     % This is output values produced by the hist command for sparsity percentage (to be used in bar plots)

total_cost_avg = [];                        % This is the total learning cost per iteration over the whole ensemble

addpath(genpath('./Common_Library'));                          % Include the library of common functions in the search path
%--------------------------------------------------------------------------

%==========================================================================

%%
%========================PROCESS ERROR RATE RESULTS========================
 
%-----------------------------Read Recall Results--------------------------
fid = fopen(['../Recall_Results/N_',num2str(N),'_K_',num2str(K),'/neural_journal_results_WTA_alpha_',num2str(alpha0),'_beta_',num2str(beta0),'_theta_',num2str(theta0),'_gamma_BFO_',num2str(gamma_BFO),'_gamma_BFS_',num2str(gamma_BFS),'.txt'], 'r');  
if (fid > -1)
    results_WTA = fscanf(fid, '%s %d %s %f %s %f',[10,inf]);
    fclose(fid);
else
    error('Undefined WTA input file!')
end

fid = fopen(['../Recall_Results/N_',num2str(N),'_K_',num2str(K),'/neural_journal_results_BFS_alpha_',num2str(alpha0),'_beta_',num2str(beta0),'_theta_',num2str(theta0),'_gamma_BFO_',num2str(gamma_BFO),'_gamma_BFS_',num2str(gamma_BFS),'.txt'], 'r');  
if (fid > -1)
    results_BFS = fscanf(fid, '%s %d %s %f %s %f',[10,inf]);
    fclose(fid);
else
    error('Undefined BFS input file!')
end

fid = fopen(['../Recall_Results/N_',num2str(N),'_K_',num2str(K),'/neural_journal_results_BFO_alpha_',num2str(alpha0),'_beta_',num2str(beta0),'_theta_',num2str(theta0),'_gamma_BFO_',num2str(gamma_BFO),'_gamma_BFS_',num2str(gamma_BFS),'.txt'], 'r');  
if (fid > -1)
    results_BFO = fscanf(fid, '%s %d %s %f %s %f',[10,inf]);
    fclose(fid);
else
    error('Undefined BFO input file!')    
end
%--------------------------------------------------------------------------
        
%-----------------------Process the Results--------------------------------
unprocessed_error_bits_WTA = results_WTA(2,:);
unprocessed_PER_WTA = results_WTA(6,:);
unprocessed_BER_WTA = results_WTA(10,:);
unprocessed_error_bits_BFO = results_BFO(2,:);
unprocessed_PER_BFO = results_BFO(6,:);
unprocessed_BER_BFO = results_BFO(10,:);
unprocessed_error_bits_BFS = results_BFS(2,:);
unprocessed_PER_BFS = results_BFS(6,:);
unprocessed_BER_BFS = results_BFS(10,:);

processed_error_bits_WTA = [0];
processed_PER_WTA = [0];
processed_BER_WTA = [0];
processed_error_bits_BFO = [0];
processed_PER_BFO = [0];
processed_BER_BFO = [0];
processed_error_bits_BFS = [0];
processed_PER_BFS = [0];
processed_BER_BFS = [0];
processed_count_WTA = [1];
processed_count_BFO = [1];
processed_count_BFS = [1];
    
for i = 1:length(unprocessed_error_bits_WTA)
    processed_flag = 0;
    for j = 1:length(processed_error_bits_WTA)
        if (unprocessed_error_bits_WTA(i) == processed_error_bits_WTA(j))
            processed_flag = 1;
            break;
        end
    end
    
    if (processed_flag == 0)
        processed_error_bits_WTA = [processed_error_bits_WTA,unprocessed_error_bits_WTA(i)];
        processed_PER_WTA = [processed_PER_WTA,unprocessed_PER_WTA(i)];
        processed_BER_WTA = [processed_BER_WTA,unprocessed_BER_WTA(i)];
        processed_count_WTA = [processed_count_WTA,1];
    else
        processed_PER_WTA(j) = processed_PER_WTA(j) + unprocessed_PER_WTA(i);
        processed_BER_WTA(j) = processed_BER_WTA(j) + unprocessed_BER_WTA(i);
        processed_count_WTA(j) = processed_count_WTA(j) + 1;
    end
end
processed_PER_WTA = processed_PER_WTA./processed_count_WTA;
processed_BER_WTA = processed_BER_WTA./processed_count_WTA;

for i = 1:length(unprocessed_error_bits_BFO)
    processed_flag = 0;
    for j = 1:length(processed_error_bits_BFO)
        if (unprocessed_error_bits_BFO(i) == processed_error_bits_BFO(j))
            processed_flag = 1;
            break;
        end
    end
    
    if (processed_flag == 0)
        processed_error_bits_BFO = [processed_error_bits_BFO,unprocessed_error_bits_BFO(i)];
        processed_PER_BFO = [processed_PER_BFO,unprocessed_PER_BFO(i)];
        processed_BER_BFO = [processed_BER_BFO,unprocessed_BER_BFO(i)];
        processed_count_BFO = [processed_count_BFO,1];
    else
        processed_PER_BFO(j) = processed_PER_BFO(j) + unprocessed_PER_BFO(i);
        processed_BER_BFO(j) = processed_BER_BFO(j) + unprocessed_BER_BFO(i);
        processed_count_BFO(j) = processed_count_BFO(j) + 1;
    end
end
processed_PER_BFO = processed_PER_BFO./processed_count_BFO;
processed_BER_BFO = processed_BER_BFO./processed_count_BFO;

for i = 1:length(unprocessed_error_bits_BFS)
    processed_flag = 0;
    for j = 1:length(processed_error_bits_BFS)
        if (unprocessed_error_bits_BFS(i) == processed_error_bits_BFS(j))
            processed_flag = 1;
            break;
        end
    end
    
    if (processed_flag == 0)
        processed_error_bits_BFS = [processed_error_bits_BFS,unprocessed_error_bits_BFS(i)];
        processed_PER_BFS = [processed_PER_BFS,unprocessed_PER_BFS(i)];
        processed_BER_BFS = [processed_BER_BFS,unprocessed_BER_BFS(i)];
        processed_count_BFS = [processed_count_BFS,1];
    else
        processed_PER_BFS(j) = processed_PER_BFS(j) + unprocessed_PER_BFS(i);
        processed_BER_BFS(j) = processed_BER_BFS(j) + unprocessed_BER_BFS(i);
        processed_count_BFS(j) = processed_count_BFS(j) + 1;
    end
end
processed_PER_BFS = processed_PER_BFS./processed_count_BFS;
processed_BER_BFS = processed_BER_BFS./processed_count_BFS;
processed_error_bits = processed_error_bits_BFO;    
%--------------------------------------------------------------------------

%------------------------Display The Results on Graph----------------------
if (plot_flag)
    figure;
    plot(sort(processed_error_bits_WTA),sort(processed_PER_WTA),'b','LineWidth',2,'Color','b');
    hold on
    plot(sort(processed_error_bits_BFO),sort(processed_PER_BFO),'b--','LineWidth',2,'Color','r');
    plot(sort(processed_error_bits_BFS),sort(processed_PER_BFS),'b-.','LineWidth',2,'Color','k');
    title('Pattern Error Rate vs. Initial Number of Errors')
    set(gca,'FontSize',16);    
    legend('WTA','BFO','BFS')
    xlabel('Initial number of errors')
    ylabel('Final Pattern Error Rate')
%--------------------------------------------------------------------------
    
%------------------------Display The Results on Graph----------------------
    figure;
    plot(sort(processed_error_bits_WTA),sort(processed_BER_WTA),'b','LineWidth',2,'Color','b');
    hold on
    plot(sort(processed_error_bits_BFO),sort(processed_BER_BFO),'b--','LineWidth',2,'Color','r');
    plot(sort(processed_error_bits_BFS),sort(processed_BER_BFS),'b-.','LineWidth',2,'Color','k');
    title('Bit Error Rate vs. Initial Number of Errors')
    set(gca,'FontSize',16);    
    legend('WTA','BFO','BFS')
    xlabel('Initial number of errors')
    ylabel('Final Bit Error Rate')
end
%--------------------------------------------------------------------------

%==========================================================================


%========================PROCESS LEARNING RESULTS==========================

%-----------------Read Total Learn Iterations From the File-----------------
fid = fopen(['../Learn_Results/N_',num2str(N),'_K_',num2str(K),'/Learn_itr_alpha_',num2str(alpha0),'_theta_',num2str(theta0),'_index_',num2str(1),'.txt'], 'r');
learn_itr = fscanf(fid, '%d',[1,inf]);        
no_local_constraints = length(learn_itr);                
fclose(fid);    
%---------------------------------------------------------------------------
    
%---------------------------Construct the Output----------------------------
[m,xout] = hist(learn_itr,hist_x_axis_itr);
hist_x_itr = [hist_x_itr;xout];
hist_out_itr = [hist_out_itr;m/no_local_constraints];        
%---------------------------------------------------------------------------  
        
    
%----------------------Display Sparsity Percentage-------------------------
[deg_row,deg_column,lambda,rho] = deg_dribution(N,K,alpha0,beta0,theta0,index_max);                

if (plot_flag)
    figure;
    bar(deg_row/(N),rho','grouped');
    colormap(summer);

    title('Total Sparsity Percentage for Different Constraint Nodes','fontsize',12);
    xlabel('Total Sparsity Percentage','fontsize',16);
    ylabel('Percentage of nodes with the specified degree of sparsity','fontsize',12);
    set(gca,'FontSize',16);


    figure;
    bar(deg_column/(N-K),lambda','grouped');
    colormap(summer);
    
    title('Total Sparsity Percentage for Different Variable Nodes','fontsize',12);
    xlabel('Total Sparsity Percentage','fontsize',16);
    ylabel('Percentage of nodes with the specified degree of sparsity','fontsize',12);
    set(gca,'FontSize',16);
end
%--------------------------------------------------------------------------    
    
%----------------------Display Sample Learning Costs------------------------
% This part does not work for now
%figure;
for ind = 1:0%index_max
    
    %-------------------Read Iteration Costs From the File------------------
    fid = fopen(['../Learn_Results/N_',num2str(N),'_K_',num2str(K),'/Learn_cost_alpha_',num2str(alpha0),'_theta_',num2str(theta0),'_index_',num2str(ind),'.txt'], 'r');
    
    learn_costs = fscanf(fid, '%f');               
    fclose(fid);    
    %-----------------------------------------------------------------------
    
    %--------------------------Process the costs----------------------------
    total_cost = [];
    marker = 0;
    no_consts = 0;
    for i = 1:length(learn_costs)-1
        if ( (learn_costs(i+1) > 0) && (learn_costs(i) < 0))
            temp = exp(learn_costs(marker+1:i))';
            marker = i;
            no_consts = no_consts + 1;
            l1 = length(temp);
            l2 = length(total_cost);
            if (l1 < l2)
                temp = [temp,zeros(1,l2-l1)];
                total_cost = total_cost + temp;
            else
                total_cost = [total_cost,zeros(1,l1-l2)];
                total_cost = total_cost + temp;
            end
        end
    end
    l1 = length(total_cost_avg);                
    l2 = length(total_cost);                
    if (l1 < l2)                    
        total_cost_avg = [total_cost_avg,zeros(1,l2-l1)];
        total_cost_avg = total_cost + total_cost_avg;                
    else            
        total_cost = [total_cost,zeros(1,l1-l2)];            
        total_cost_avg = total_cost + total_cost_avg;                
    end
end    
total_cost_avg = total_cost_avg/index_max;
        
if (0)
    plot((total_cost_avg),'b--','LineWidth',2,'Color','b');
        
    title('MSE as a Function of Learning Iteration','fontsize',16);
    xlabel('Learning iterations','fontsize',16);
    ylabel('MSE','fontsize',16);
    set(gca,'FontSize',16);
end
%--------------------------------------------------------------------------
    
    
%==========================================================================